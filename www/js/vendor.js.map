{"version":3,"file":"www/js/vendor.js","sources":["vendor/angular-localForage.js","vendor/localforage.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * copyright: Olivier Combe (https://github.com/ocombe/angular-localForage)\n */\n\n(function(window, angular, undefined) {\n\t'use strict';\n\n\tvar angularLocalForage = angular.module('LocalForageModule', ['ng']);\n\tangularLocalForage.provider('$localForage', function() {\n        window.localForageConfig = {\n            name: 'lf' // default prefix\n        };\n\n\t\t// Send signals for each of the following actions ?\n\t\tthis.notify = {\n\t\t\tsetItem: false,\n\t\t\tremoveItem: false\n\t\t};\n\n\t\t// Setter for the prefix\n\t\tthis.setPrefix = function(prefix) {\n            if(angular.isDefined(prefix) && prefix !== window.localForageConfig.name) {\n                window.localForageConfig.name = prefix;\n                localforage._initStorage(window.localForageConfig);\n            }\n\t\t};\n\n\t\t// Setter for the storage driver\n\t\tvar setDriver = function(driver) {\n\t\t\treturn localforage.setDriver(driver);\n\t\t};\n\n\t\tthis.setDriver = setDriver;\n\n\t\t// Getter for the storage driver\n\t\tvar driver = function() {\n\t\t\treturn localforage.driver();\n\t\t};\n\n\t\t// Setter for notification config, itemSet & itemRemove should be booleans\n\t\tthis.setNotify = function(itemSet, itemRemove) {\n\t\t\tthis.notify = {\n\t\t\t\tsetItem: itemSet,\n\t\t\t\tremoveItem: itemRemove\n\t\t\t};\n\t\t};\n\n        this.config = function(config) {\n            if(angular.isObject(config)) {\n                window.localForageConfig = config;\n                if(angular.isDefined(config.driver)) {\n                    return setDriver(config.driver);\n                } else {\n                    return localforage._initStorage(config);\n                }\n            }\n        }\n\n\t\tthis.$get = ['$rootScope', '$q', '$parse', function($rootScope, $q, $parse) {\n\t\t\tvar notify = this.notify;\n\t\t\tvar watchers = {};\n\n            var prefix = function() {\n                return driver() === 'localStorageWrapper' ? 'lfp.' : '';\n            }\n\n\t\t\tvar onError = function(data, args, fct, deferred) {\n\t\t\t\tif(data === 'InvalidStateError' && driver() === 'asyncStorage') {\n\t\t\t\t\tsetDriver('localStorageWrapper').then(function() {\n\t\t\t\t\t\tfct(args).then(function(item) {\n\t\t\t\t\t\t\tdeferred.resolve(item);\n\t\t\t\t\t\t}, function(data) {\n\t\t\t\t\t\t\tdeferred.reject(data);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, function() {\n\t\t\t\t\t\tdeferred.reject(data);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.reject(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Directly adds a value to storage\n\t\t\tvar setItem = function(key, value) {\n\t\t\t\tvar deferred = $q.defer(),\n\t\t\t\t\targs = arguments;\n\t\t\t\tlocalforage.setItem(prefix() + key, value).then(function success() {\n\t\t\t\t\tif(notify.setItem) {\n\t\t\t\t\t\t$rootScope.$broadcast('LocalForageModule.setItem', {key: key, newvalue: value, driver: localforage.driver()});\n\t\t\t\t\t}\n\t\t\t\t\tdeferred.resolve();\n\t\t\t\t}, function error(data) {\n\t\t\t\t\tonError(data, args, setItem, deferred);\n\t\t\t\t});\n\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\n\t\t\t// Directly get a value from storage\n\t\t\tvar getItem = function(key) {\n\t\t\t\tvar deferred = $q.defer(),\n\t\t\t\t\targs = arguments;\n\t\t\t\tlocalforage.getItem(prefix() + key).then(function success(item) {\n\t\t\t\t\tdeferred.resolve(item);\n\t\t\t\t}, function error(data) {\n\t\t\t\t\tonError(data, args, getItem, deferred);\n\t\t\t\t});\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\n\t\t\t// Remove an item from storage\n\t\t\tvar removeItem = function(key) {\n\t\t\t\tvar promise = localforage.removeItem(prefix() + key);\n\t\t\t\tif(notify.setItem) {\n\t\t\t\t\treturn promise.then(function(value) {\n\t\t\t\t\t\t$rootScope.$broadcast('LocalForageModule.removeItem', {key: key, driver: localforage.driver()});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Remove all data for this app from storage (we could use localforage.clear(); but we don't want to remove things without the prefix\n\t\t\tvar clear = function() {\n\t\t\t\tvar deferred = $q.defer(),\n\t\t\t\t\targs = arguments,\n\t\t\t\t\tpromises = [];\n\t\t\t\tgetKeys().then(function success(keys) {\n\t\t\t\t\tangular.forEach(keys, function(key) {\n\t\t\t\t\t\tpromises.push(removeItem(key));\n\t\t\t\t\t});\n\n\t\t\t\t\t$q.all(promises).then(function() {\n\t\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\t});\n\t\t\t\t}, function error(data) {\n\t\t\t\t\tonError(data, args, clearAll, deferred);\n\t\t\t\t});\n\t\t\t\treturn deferred.promise;\n\t\t\t}\n\n\t\t\t// Return the key for item at position n\n\t\t\tvar key = function(n) {\n\t\t\t\tvar deferred = $q.defer(),\n\t\t\t\t\targs = arguments;\n\t\t\t\tlocalforage.key(n).then(function success(key) {\n\t\t\t\t\tdeferred.resolve(key);\n\t\t\t\t}, function error(data) {\n\t\t\t\t\tonError(data, args, key, deferred);\n\t\t\t\t});\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\n\t\t\tvar length = function() {\n\t\t\t\tvar deferred = $q.defer(),\n\t\t\t\t\targs = arguments; // using $q to avoid using $apply\n\t\t\t\tlocalforage.length().then(function success(length) {\n\t\t\t\t\tdeferred.resolve(length);\n\t\t\t\t}, function error(data) {\n\t\t\t\t\tonError(data, args, length, deferred);\n\t\t\t\t});\n\t\t\t\treturn deferred.promise;\n\t\t\t}\n\n\t\t\t// Return the list of keys stored for this application\n\t\t\tvar getKeys = function() {\n\t\t\t\tvar deferred = $q.defer(),\n\t\t\t\t\targs = arguments;\n\t\t\t\tlength().then(function success(length) {\n\t\t\t\t\tvar promises = [],\n\t\t\t\t\t\tkeys = [],\n                        p = prefix();\n\t\t\t\t\tfor(var i = 0; i < length; i++) {\n\t\t\t\t\t\tpromises.push(key(i).then(function(key) {\n\t\t\t\t\t\t\tif(key.indexOf(p) === 0) {\n\t\t\t\t\t\t\t\tkeys.push(key.substr(p.length, key.length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\n\t\t\t\t\t$q.all(promises).then(function() {\n\t\t\t\t\t\tdeferred.resolve(keys);\n\t\t\t\t\t});\n\t\t\t\t}, function error(data) {\n\t\t\t\t\tonError(data, args, getKeys, deferred);\n\t\t\t\t});\n\t\t\t\treturn deferred.promise;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Bind - let's you directly bind a LocalForage value to a $scope variable\n\t\t\t * @param {Angular $scope} $scope - the current scope you want the variable available in\n\t\t\t * @param {String} key - the name of the variable you are binding\n\t\t\t * @param {String} key - the name of the variable you are binding OR {Object} opts - key and custom options like default value or unique store name\n\t\t\t * Here are the available options you can set:\n\t\t\t * * defaultValue: the default value\n\t\t\t * * storeName: add a custom store key value instead of using the scope variable name\n\t\t\t * @returns {*} - returns whatever the stored value is\n\t\t\t */\n\t\t\tvar bind = function($scope, opts) {\n\t\t\t\tif(angular.isString(opts)) {\n\t\t\t\t\topts = {\n\t\t\t\t\t\tkey: opts\n\t\t\t\t\t}\n\t\t\t\t} else if(!angular.isObject(opts) || angular.isUndefined(opts.key)) {\n\t\t\t\t\tthrow \"You must defined a key to bind\";\n\t\t\t\t}\n\t\t\t\tvar defaultOpts = {\n\t\t\t\t\tdefaultValue: '',\n\t\t\t\t\tstoreName: ''\n\t\t\t\t};\n\t\t\t\t// If no defined options we use defaults otherwise extend defaults\n\t\t\t\topts = angular.extend(defaultOpts, opts || {});\n\n\t\t\t\t// Set the storeName key for the LocalForage entry\n\t\t\t\t// use user defined in specified\n\t\t\t\tvar storeName = opts.storeName || opts.key,\n\t\t\t\t\tmodel = $parse(opts.key);\n\n\t\t\t\treturn getItem(storeName).then(function(item) {\n\t\t\t\t\tif(item) { // If it does exist assign it to the $scope value\n\t\t\t\t\t\tmodel.assign($scope, item);\n\t\t\t\t\t} else if(opts.defaultValue) { // If a value doesn't already exist store it as is\n\t\t\t\t\t\tsetItem(storeName, opts.defaultValue);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Register a listener for changes on the $scope value\n\t\t\t\t\t// to update the localForage value\n\t\t\t\t\tif(angular.isDefined(watchers[opts.key])) {\n\t\t\t\t\t\twatchers[opts.key]();\n\t\t\t\t\t}\n\n\t\t\t\t\twatchers[opts.key] = $scope.$watch($parse(opts.key), function(val) {\n\t\t\t\t\t\tif(angular.isDefined(val)) {\n\t\t\t\t\t\t\tsetItem(storeName, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, true);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Unbind - let's you unbind a variable from localForage while removing the value from both\n\t\t\t * the localForage and the local variable and sets it to null\n\t\t\t * @param $scope - the scope the variable was initially set in\n\t\t\t * @param key - the name of the variable you are unbinding\n\t\t\t * @param storeName - (optional) if you used a custom storeName you will have to specify it here as well\n\t\t\t */\n\t\t\tvar unbind = function($scope, key, storeName) {\n\t\t\t\tstoreName = storeName || key;\n\t\t\t\t$parse(key).assign($scope, null);\n\t\t\t\tif(angular.isDefined(watchers[key])) {\n\t\t\t\t\twatchers[key](); // unwatch\n\t\t\t\t\tdelete watchers[key];\n\t\t\t\t}\n\t\t\t\tremoveItem(storeName);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsetDriver: setDriver,\n                driver: driver,\n\t\t\t\tgetDriver: driver, // deprecated\n\t\t\t\tsetItem: setItem,\n                set: setItem, // deprecated\n                getItem: getItem,\n                get: getItem, // deprecated\n\t\t\t\tremove: removeItem,\n                removeItem: removeItem, // deprecated\n\t\t\t\tclear: clear,\n\t\t\t\tclearAll: clear, // deprecated\n                key: key,\n\t\t\t\tgetKeyAt: key, // deprecated\n\t\t\t\tgetKeys: getKeys,\n\t\t\t\tlength: length,\n\t\t\t\tgetLength: length, // deprecated\n\t\t\t\tbind: bind,\n\t\t\t\tunbind: unbind\n\t\t\t};\n\t\t}]\n\t});\n\n\tangularLocalForage.directive('localForage', ['$localForage', function ($localForage) {\n\t\treturn {\n\t\t\trestrict: 'A',\n\t\t\tlink: function ($scope, $element, $attrs) {\n\t\t\t\tvar opts = $scope.$eval($attrs.localForage);\n\t\t\t\tif(angular.isObject(opts) && angular.isDefined(opts.key) && angular.isDefined(opts.storeName)) {\n\t\t\t\t\t$localForage.bind($scope, opts);\n\t\t\t\t} else {\n\t\t\t\t\t$localForage.bind($scope, $attrs.localForage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n})(window, window.angular);","/*!\n    localForage -- Offline Storage, Improved\n    Version 0.1.0\n    http://mozilla.github.io/localForage\n    (c) 2013-2014 Mozilla, Apache License 2.0\n*/\n(function() {\nvar define, requireModule, require, requirejs;\n\n(function() {\n  var registry = {}, seen = {};\n\n  define = function(name, deps, callback) {\n    registry[name] = { deps: deps, callback: callback };\n  };\n\n  requirejs = require = requireModule = function(name) {\n  requirejs._eak_seen = registry;\n\n    if (seen[name]) { return seen[name]; }\n    seen[name] = {};\n\n    if (!registry[name]) {\n      throw new Error(\"Could not find module \" + name);\n    }\n\n    var mod = registry[name],\n        deps = mod.deps,\n        callback = mod.callback,\n        reified = [],\n        exports;\n\n    for (var i=0, l=deps.length; i<l; i++) {\n      if (deps[i] === 'exports') {\n        reified.push(exports = {});\n      } else {\n        reified.push(requireModule(resolve(deps[i])));\n      }\n    }\n\n    var value = callback.apply(this, reified);\n    return seen[name] = exports || value;\n\n    function resolve(child) {\n      if (child.charAt(0) !== '.') { return child; }\n      var parts = child.split(\"/\");\n      var parentBase = name.split(\"/\").slice(0, -1);\n\n      for (var i=0, l=parts.length; i<l; i++) {\n        var part = parts[i];\n\n        if (part === '..') { parentBase.pop(); }\n        else if (part === '.') { continue; }\n        else { parentBase.push(part); }\n      }\n\n      return parentBase.join(\"/\");\n    }\n  };\n})();\n\ndefine(\"promise/all\",\n  [\"./utils\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    /* global toString */\n\n    var isArray = __dependency1__.isArray;\n    var isFunction = __dependency1__.isFunction;\n\n    /**\n      Returns a promise that is fulfilled when all the given promises have been\n      fulfilled, or rejected if any of them become rejected. The return promise\n      is fulfilled with an array that gives all the values in the order they were\n      passed in the `promises` array argument.\n\n      Example:\n\n      ```javascript\n      var promise1 = RSVP.resolve(1);\n      var promise2 = RSVP.resolve(2);\n      var promise3 = RSVP.resolve(3);\n      var promises = [ promise1, promise2, promise3 ];\n\n      RSVP.all(promises).then(function(array){\n        // The array here would be [ 1, 2, 3 ];\n      });\n      ```\n\n      If any of the `promises` given to `RSVP.all` are rejected, the first promise\n      that is rejected will be given as an argument to the returned promises's\n      rejection handler. For example:\n\n      Example:\n\n      ```javascript\n      var promise1 = RSVP.resolve(1);\n      var promise2 = RSVP.reject(new Error(\"2\"));\n      var promise3 = RSVP.reject(new Error(\"3\"));\n      var promises = [ promise1, promise2, promise3 ];\n\n      RSVP.all(promises).then(function(array){\n        // Code here never runs because there are rejected promises!\n      }, function(error) {\n        // error.message === \"2\"\n      });\n      ```\n\n      @method all\n      @for RSVP\n      @param {Array} promises\n      @param {String} label\n      @return {Promise} promise that is fulfilled when all `promises` have been\n      fulfilled, or rejected if any of them become rejected.\n    */\n    function all(promises) {\n      /*jshint validthis:true */\n      var Promise = this;\n\n      if (!isArray(promises)) {\n        throw new TypeError('You must pass an array to all.');\n      }\n\n      return new Promise(function(resolve, reject) {\n        var results = [], remaining = promises.length,\n        promise;\n\n        if (remaining === 0) {\n          resolve([]);\n        }\n\n        function resolver(index) {\n          return function(value) {\n            resolveAll(index, value);\n          };\n        }\n\n        function resolveAll(index, value) {\n          results[index] = value;\n          if (--remaining === 0) {\n            resolve(results);\n          }\n        }\n\n        for (var i = 0; i < promises.length; i++) {\n          promise = promises[i];\n\n          if (promise && isFunction(promise.then)) {\n            promise.then(resolver(i), reject);\n          } else {\n            resolveAll(i, promise);\n          }\n        }\n      });\n    }\n\n    __exports__.all = all;\n  });\ndefine(\"promise/asap\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var browserGlobal = (typeof window !== 'undefined') ? window : {};\n    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n    var local = (typeof global !== 'undefined') ? global : this;\n\n    // node\n    function useNextTick() {\n      return function() {\n        process.nextTick(flush);\n      };\n    }\n\n    function useMutationObserver() {\n      var iterations = 0;\n      var observer = new BrowserMutationObserver(flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    function useSetTimeout() {\n      return function() {\n        local.setTimeout(flush, 1);\n      };\n    }\n\n    var queue = [];\n    function flush() {\n      for (var i = 0; i < queue.length; i++) {\n        var tuple = queue[i];\n        var callback = tuple[0], arg = tuple[1];\n        callback(arg);\n      }\n      queue = [];\n    }\n\n    var scheduleFlush;\n\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n      scheduleFlush = useNextTick();\n    } else if (BrowserMutationObserver) {\n      scheduleFlush = useMutationObserver();\n    } else {\n      scheduleFlush = useSetTimeout();\n    }\n\n    function asap(callback, arg) {\n      var length = queue.push([callback, arg]);\n      if (length === 1) {\n        // If length is 1, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        scheduleFlush();\n      }\n    }\n\n    __exports__.asap = asap;\n  });\ndefine(\"promise/cast\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    /**\n      `RSVP.Promise.cast` returns the same promise if that promise shares a constructor\n      with the promise being casted.\n\n      Example:\n\n      ```javascript\n      var promise = RSVP.resolve(1);\n      var casted = RSVP.Promise.cast(promise);\n\n      console.log(promise === casted); // true\n      ```\n\n      In the case of a promise whose constructor does not match, it is assimilated.\n      The resulting promise will fulfill or reject based on the outcome of the\n      promise being casted.\n\n      In the case of a non-promise, a promise which will fulfill with that value is\n      returned.\n\n      Example:\n\n      ```javascript\n      var value = 1; // could be a number, boolean, string, undefined...\n      var casted = RSVP.Promise.cast(value);\n\n      console.log(value === casted); // false\n      console.log(casted instanceof RSVP.Promise) // true\n\n      casted.then(function(val) {\n        val === value // => true\n      });\n      ```\n\n      `RSVP.Promise.cast` is similar to `RSVP.resolve`, but `RSVP.Promise.cast` differs in the\n      following ways:\n      * `RSVP.Promise.cast` serves as a memory-efficient way of getting a promise, when you\n      have something that could either be a promise or a value. RSVP.resolve\n      will have the same effect but will create a new promise wrapper if the\n      argument is a promise.\n      * `RSVP.Promise.cast` is a way of casting incoming thenables or promise subclasses to\n      promises of the exact class specified, so that the resulting object's `then` is\n      ensured to have the behavior of the constructor you are calling cast on (i.e., RSVP.Promise).\n\n      @method cast\n      @for RSVP\n      @param {Object} object to be casted\n      @return {Promise} promise that is fulfilled when all properties of `promises`\n      have been fulfilled, or rejected if any of them become rejected.\n    */\n\n\n    function cast(object) {\n      /*jshint validthis:true */\n      if (object && typeof object === 'object' && object.constructor === this) {\n        return object;\n      }\n\n      var Promise = this;\n\n      return new Promise(function(resolve) {\n        resolve(object);\n      });\n    }\n\n    __exports__.cast = cast;\n  });\ndefine(\"promise/config\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var config = {\n      instrument: false\n    };\n\n    function configure(name, value) {\n      if (arguments.length === 2) {\n        config[name] = value;\n      } else {\n        return config[name];\n      }\n    }\n\n    __exports__.config = config;\n    __exports__.configure = configure;\n  });\ndefine(\"promise/polyfill\",\n  [\"./promise\",\"./utils\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var RSVPPromise = __dependency1__.Promise;\n    var isFunction = __dependency2__.isFunction;\n\n    function polyfill() {\n      var es6PromiseSupport =\n        \"Promise\" in window &&\n        // Some of these methods are missing from\n        // Firefox/Chrome experimental implementations\n        \"cast\" in window.Promise &&\n        \"resolve\" in window.Promise &&\n        \"reject\" in window.Promise &&\n        \"all\" in window.Promise &&\n        \"race\" in window.Promise &&\n        // Older version of the spec had a resolver object\n        // as the arg rather than a function\n        (function() {\n          var resolve;\n          new window.Promise(function(r) { resolve = r; });\n          return isFunction(resolve);\n        }());\n\n      if (!es6PromiseSupport) {\n        window.Promise = RSVPPromise;\n      }\n    }\n\n    __exports__.polyfill = polyfill;\n  });\ndefine(\"promise/promise\",\n  [\"./config\",\"./utils\",\"./cast\",\"./all\",\"./race\",\"./resolve\",\"./reject\",\"./asap\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __exports__) {\n    \"use strict\";\n    var config = __dependency1__.config;\n    var configure = __dependency1__.configure;\n    var objectOrFunction = __dependency2__.objectOrFunction;\n    var isFunction = __dependency2__.isFunction;\n    var now = __dependency2__.now;\n    var cast = __dependency3__.cast;\n    var all = __dependency4__.all;\n    var race = __dependency5__.race;\n    var staticResolve = __dependency6__.resolve;\n    var staticReject = __dependency7__.reject;\n    var asap = __dependency8__.asap;\n\n    var counter = 0;\n\n    config.async = asap; // default async is asap;\n\n    function Promise(resolver) {\n      if (!isFunction(resolver)) {\n        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n      }\n\n      if (!(this instanceof Promise)) {\n        throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n      }\n\n      this._subscribers = [];\n\n      invokeResolver(resolver, this);\n    }\n\n    function invokeResolver(resolver, promise) {\n      function resolvePromise(value) {\n        resolve(promise, value);\n      }\n\n      function rejectPromise(reason) {\n        reject(promise, reason);\n      }\n\n      try {\n        resolver(resolvePromise, rejectPromise);\n      } catch(e) {\n        rejectPromise(e);\n      }\n    }\n\n    function invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        try {\n          value = callback(detail);\n          succeeded = true;\n        } catch(e) {\n          failed = true;\n          error = e;\n        }\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (handleThenable(promise, value)) {\n        return;\n      } else if (hasCallback && succeeded) {\n        resolve(promise, value);\n      } else if (failed) {\n        reject(promise, error);\n      } else if (settled === FULFILLED) {\n        resolve(promise, value);\n      } else if (settled === REJECTED) {\n        reject(promise, value);\n      }\n    }\n\n    var PENDING   = void 0;\n    var SEALED    = 0;\n    var FULFILLED = 1;\n    var REJECTED  = 2;\n\n    function subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      subscribers[length] = child;\n      subscribers[length + FULFILLED] = onFulfillment;\n      subscribers[length + REJECTED]  = onRejection;\n    }\n\n    function publish(promise, settled) {\n      var child, callback, subscribers = promise._subscribers, detail = promise._detail;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        invokeCallback(settled, child, callback, detail);\n      }\n\n      promise._subscribers = null;\n    }\n\n    Promise.prototype = {\n      constructor: Promise,\n\n      _state: undefined,\n      _detail: undefined,\n      _subscribers: undefined,\n\n      then: function(onFulfillment, onRejection) {\n        var promise = this;\n\n        var thenPromise = new this.constructor(function() {});\n\n        if (this._state) {\n          var callbacks = arguments;\n          config.async(function invokePromiseCallback() {\n            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);\n          });\n        } else {\n          subscribe(this, thenPromise, onFulfillment, onRejection);\n        }\n\n        return thenPromise;\n      },\n\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n\n    Promise.all = all;\n    Promise.cast = cast;\n    Promise.race = race;\n    Promise.resolve = staticResolve;\n    Promise.reject = staticReject;\n\n    function handleThenable(promise, value) {\n      var then = null,\n      resolved;\n\n      try {\n        if (promise === value) {\n          throw new TypeError(\"A promises callback cannot return that same promise.\");\n        }\n\n        if (objectOrFunction(value)) {\n          then = value.then;\n\n          if (isFunction(then)) {\n            then.call(value, function(val) {\n              if (resolved) { return true; }\n              resolved = true;\n\n              if (value !== val) {\n                resolve(promise, val);\n              } else {\n                fulfill(promise, val);\n              }\n            }, function(val) {\n              if (resolved) { return true; }\n              resolved = true;\n\n              reject(promise, val);\n            });\n\n            return true;\n          }\n        }\n      } catch (error) {\n        if (resolved) { return true; }\n        reject(promise, error);\n        return true;\n      }\n\n      return false;\n    }\n\n    function resolve(promise, value) {\n      if (promise === value) {\n        fulfill(promise, value);\n      } else if (!handleThenable(promise, value)) {\n        fulfill(promise, value);\n      }\n    }\n\n    function fulfill(promise, value) {\n      if (promise._state !== PENDING) { return; }\n      promise._state = SEALED;\n      promise._detail = value;\n\n      config.async(publishFulfillment, promise);\n    }\n\n    function reject(promise, reason) {\n      if (promise._state !== PENDING) { return; }\n      promise._state = SEALED;\n      promise._detail = reason;\n\n      config.async(publishRejection, promise);\n    }\n\n    function publishFulfillment(promise) {\n      publish(promise, promise._state = FULFILLED);\n    }\n\n    function publishRejection(promise) {\n      publish(promise, promise._state = REJECTED);\n    }\n\n    __exports__.Promise = Promise;\n  });\ndefine(\"promise/race\",\n  [\"./utils\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    /* global toString */\n    var isArray = __dependency1__.isArray;\n\n    /**\n      `RSVP.race` allows you to watch a series of promises and act as soon as the\n      first promise given to the `promises` argument fulfills or rejects.\n\n      Example:\n\n      ```javascript\n      var promise1 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve(\"promise 1\");\n        }, 200);\n      });\n\n      var promise2 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve(\"promise 2\");\n        }, 100);\n      });\n\n      RSVP.race([promise1, promise2]).then(function(result){\n        // result === \"promise 2\" because it was resolved before promise1\n        // was resolved.\n      });\n      ```\n\n      `RSVP.race` is deterministic in that only the state of the first completed\n      promise matters. For example, even if other promises given to the `promises`\n      array argument are resolved, but the first completed promise has become\n      rejected before the other promises became fulfilled, the returned promise\n      will become rejected:\n\n      ```javascript\n      var promise1 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve(\"promise 1\");\n        }, 200);\n      });\n\n      var promise2 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          reject(new Error(\"promise 2\"));\n        }, 100);\n      });\n\n      RSVP.race([promise1, promise2]).then(function(result){\n        // Code here never runs because there are rejected promises!\n      }, function(reason){\n        // reason.message === \"promise2\" because promise 2 became rejected before\n        // promise 1 became fulfilled\n      });\n      ```\n\n      @method race\n      @for RSVP\n      @param {Array} promises array of promises to observe\n      @param {String} label optional string for describing the promise returned.\n      Useful for tooling.\n      @return {Promise} a promise that becomes fulfilled with the value the first\n      completed promises is resolved with if the first completed promise was\n      fulfilled, or rejected with the reason that the first completed promise\n      was rejected with.\n    */\n    function race(promises) {\n      /*jshint validthis:true */\n      var Promise = this;\n\n      if (!isArray(promises)) {\n        throw new TypeError('You must pass an array to race.');\n      }\n      return new Promise(function(resolve, reject) {\n        var results = [], promise;\n\n        for (var i = 0; i < promises.length; i++) {\n          promise = promises[i];\n\n          if (promise && typeof promise.then === 'function') {\n            promise.then(resolve, reject);\n          } else {\n            resolve(promise);\n          }\n        }\n      });\n    }\n\n    __exports__.race = race;\n  });\ndefine(\"promise/reject\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    /**\n      `RSVP.reject` returns a promise that will become rejected with the passed\n      `reason`. `RSVP.reject` is essentially shorthand for the following:\n\n      ```javascript\n      var promise = new RSVP.Promise(function(resolve, reject){\n        reject(new Error('WHOOPS'));\n      });\n\n      promise.then(function(value){\n        // Code here doesn't run because the promise is rejected!\n      }, function(reason){\n        // reason.message === 'WHOOPS'\n      });\n      ```\n\n      Instead of writing the above, your code now simply becomes the following:\n\n      ```javascript\n      var promise = RSVP.reject(new Error('WHOOPS'));\n\n      promise.then(function(value){\n        // Code here doesn't run because the promise is rejected!\n      }, function(reason){\n        // reason.message === 'WHOOPS'\n      });\n      ```\n\n      @method reject\n      @for RSVP\n      @param {Any} reason value that the returned promise will be rejected with.\n      @param {String} label optional string for identifying the returned promise.\n      Useful for tooling.\n      @return {Promise} a promise that will become rejected with the given\n      `reason`.\n    */\n    function reject(reason) {\n      /*jshint validthis:true */\n      var Promise = this;\n\n      return new Promise(function (resolve, reject) {\n        reject(reason);\n      });\n    }\n\n    __exports__.reject = reject;\n  });\ndefine(\"promise/resolve\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    /**\n      `RSVP.resolve` returns a promise that will become fulfilled with the passed\n      `value`. `RSVP.resolve` is essentially shorthand for the following:\n\n      ```javascript\n      var promise = new RSVP.Promise(function(resolve, reject){\n        resolve(1);\n      });\n\n      promise.then(function(value){\n        // value === 1\n      });\n      ```\n\n      Instead of writing the above, your code now simply becomes the following:\n\n      ```javascript\n      var promise = RSVP.resolve(1);\n\n      promise.then(function(value){\n        // value === 1\n      });\n      ```\n\n      @method resolve\n      @for RSVP\n      @param {Any} value value that the returned promise will be resolved with\n      @param {String} label optional string for identifying the returned promise.\n      Useful for tooling.\n      @return {Promise} a promise that will become fulfilled with the given\n      `value`\n    */\n    function resolve(value) {\n      /*jshint validthis:true */\n      var Promise = this;\n      return new Promise(function(resolve, reject) {\n        resolve(value);\n      });\n    }\n\n    __exports__.resolve = resolve;\n  });\ndefine(\"promise/utils\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    function objectOrFunction(x) {\n      return isFunction(x) || (typeof x === \"object\" && x !== null);\n    }\n\n    function isFunction(x) {\n      return typeof x === \"function\";\n    }\n\n    function isArray(x) {\n      return Object.prototype.toString.call(x) === \"[object Array]\";\n    }\n\n    // Date.now is not available in browsers < IE9\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility\n    var now = Date.now || function() { return new Date().getTime(); };\n\n\n    __exports__.objectOrFunction = objectOrFunction;\n    __exports__.isFunction = isFunction;\n    __exports__.isArray = isArray;\n    __exports__.now = now;\n  });\nrequireModule('promise/polyfill').polyfill();\n}());(function() {\n    'use strict';\n\n    // Originally found in https://github.com/mozilla-b2g/gaia/blob/e8f624e4cc9ea945727278039b3bc9bcb9f8667a/shared/js/async_storage.js\n\n    var Promise = this.Promise;\n    var db = null;\n    var dbInfo = {\n        name: 'localforage',\n        storeName: 'keyvaluepairs',\n        version: 1\n    };\n\n    // Initialize IndexedDB; fall back to vendor-prefixed versions if needed.\n    var indexedDB = indexedDB || this.indexedDB || this.webkitIndexedDB ||\n                    this.mozIndexedDB || this.OIndexedDB ||\n                    this.msIndexedDB;\n\n    // If IndexedDB isn't available, we get outta here!\n    if (!indexedDB) {\n        return;\n    }\n\n    // Open the IndexedDB database (automatically creates one if one didn't\n    // previously exist), using any options set in window.localForageConfig.\n    function _initStorage(options) {\n        if (options) {\n            for (var i in dbInfo) {\n                if (options[i] !== undefined) {\n                    dbInfo[i] = options[i];\n                }\n            }\n        }\n\n        return new Promise(function(resolve, reject) {\n            var openreq = indexedDB.open(dbInfo.name, dbInfo.version);\n            openreq.onerror = function withStoreOnError() {\n                reject(openreq.error.name);\n            };\n            openreq.onupgradeneeded = function withStoreOnUpgradeNeeded() {\n                // First time setup: create an empty object store\n                openreq.result.createObjectStore(dbInfo.storeName);\n            };\n            openreq.onsuccess = function withStoreOnSuccess() {\n                db = openreq.result;\n                resolve();\n            };\n        });\n    }\n\n    function getItem(key, callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                var store = db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n                var req = store.get(key);\n                req.onsuccess = function getItemOnSuccess() {\n                    var value = req.result;\n                    if (value === undefined) {\n                        value = null;\n                    }\n                    if (callback) {\n                        callback(value);\n                    }\n\n                    resolve(value);\n                };\n                req.onerror = function getItemOnError() {\n                    reject(req.error.name);\n                };\n            });\n        });\n    }\n\n    function setItem(key, value, callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                var store = db.transaction(dbInfo.storeName, 'readwrite').objectStore(dbInfo.storeName);\n\n                // Cast to undefined so the value passed to callback/promise is\n                // the same as what one would get out of `getItem()` later.\n                // This leads to some weirdness (setItem('foo', undefined) will\n                // return \"null\"), but it's not my fault localStorage is our\n                // baseline and that it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                var req = store.put(value, key);\n                req.onsuccess = function setItemOnSuccess() {\n                    if (callback) {\n                        callback(value);\n                    }\n\n                    resolve(value);\n                };\n                req.onerror = function setItemOnError() {\n                    reject(req.error.name);\n                };\n            });\n        });\n    }\n\n    function removeItem(key, callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                var store = db.transaction(dbInfo.storeName, 'readwrite').objectStore(dbInfo.storeName);\n\n                // We use `['delete']` instead of `.delete` because IE 8 will\n                // throw a fit if it sees the reserved word \"delete\" in this\n                // scenario. See: https://github.com/mozilla/localForage/pull/67\n                //\n                // This can be removed once we no longer care about IE 8, for\n                // what that's worth.\n                // TODO: Write a test against this? Maybe IE in general? Also,\n                // make sure the minify step doesn't optimise this to `.delete`,\n                // though it currently doesn't.\n                var req = store['delete'](key);\n                req.onsuccess = function removeItemOnSuccess() {\n                    if (callback) {\n                        callback();\n                    }\n                    resolve();\n                };\n                req.onerror = function removeItemOnError() {\n                    reject(req.error.name);\n                };\n            });\n        });\n    }\n\n    function clear(callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                var store = db.transaction(dbInfo.storeName, 'readwrite').objectStore(dbInfo.storeName);\n                var req = store.clear();\n                req.onsuccess = function clearOnSuccess() {\n                    if (callback) {\n                        callback();\n                    }\n\n                    resolve();\n                };\n                req.onerror = function clearOnError() {\n                    reject(req.error.name);\n                };\n            });\n        });\n    }\n\n    function length(callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                var store = db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n                var req = store.count();\n                req.onsuccess = function lengthOnSuccess() {\n                    if (callback) {\n                        callback(req.result);\n                    }\n\n                    resolve(req.result);\n                };\n                req.onerror = function lengthOnError() {\n                    reject(req.error.name);\n                };\n            });\n        });\n    }\n\n    function key(n, callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            if (n < 0) {\n                if (callback) {\n                    callback(null);\n                }\n\n                resolve(null);\n\n                return;\n            }\n\n            _this.ready().then(function() {\n                var store = db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n                var advanced = false;\n                var req = store.openCursor();\n                req.onsuccess = function keyOnSuccess() {\n                    var cursor = req.result;\n                    if (!cursor) {\n                        // this means there weren't enough keys\n                        if (callback) {\n                            callback(null);\n                        }\n\n                        resolve(null);\n\n                        return;\n                    }\n                    if (n === 0) {\n                        // We have the first key, return it if that's what they wanted\n                        if (callback) {\n                            callback(cursor.key);\n                        }\n\n                        resolve(cursor.key);\n                    } else {\n                        if (!advanced) {\n                            // Otherwise, ask the cursor to skip ahead n records\n                            advanced = true;\n                            cursor.advance(n);\n                        } else {\n                            // When we get here, we've got the nth key.\n                            if (callback) {\n                                callback(cursor.key);\n                            }\n\n                            resolve(cursor.key);\n                        }\n                    }\n                };\n\n                req.onerror = function keyOnError() {\n                    reject(req.error.name);\n                };\n            });\n        });\n    }\n\n    var asyncStorage = {\n        _driver: 'asyncStorage',\n        _initStorage: _initStorage,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('asyncStorage', function() {\n            return asyncStorage;\n        });\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = asyncStorage;\n    } else {\n        this.asyncStorage = asyncStorage;\n    }\n}).call(this);\n// If IndexedDB isn't available, we'll fall back to localStorage.\n// Note that this will have considerable performance and storage\n// side-effects (all data will be serialized on save and only data that\n// can be converted to a string via `JSON.stringify()` will be saved).\n(function() {\n    'use strict';\n\n    var keyPrefix = '';\n    var dbInfo = {\n        name: 'localforage'\n    };\n    var Promise = this.Promise;\n    var localStorage = null;\n\n    // If the app is running inside a Google Chrome packaged webapp, or some\n    // other context where localStorage isn't available, we don't use\n    // localStorage. This feature detection is preferred over the old\n    // `if (window.chrome && window.chrome.runtime)` code.\n    // See: https://github.com/mozilla/localForage/issues/68\n    try {\n        // Initialize localStorage and create a variable to use throughout\n        // the code.\n        localStorage = this.localStorage;\n    } catch (e) {\n        return;\n    }\n\n    // Config the localStorage backend, using options set in\n    // window.localForageConfig.\n    function _initStorage(options) {\n        if (options) {\n            for (var i in dbInfo) {\n                if (options[i] !== undefined) {\n                    dbInfo[i] = options[i];\n                }\n            }\n        }\n\n        keyPrefix = dbInfo.name + '/';\n\n        return Promise.resolve();\n    }\n\n    var SERIALIZED_MARKER = '__lfsc__:';\n    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n    // OMG the serializations!\n    var TYPE_ARRAYBUFFER = 'arbf';\n    var TYPE_BLOB = 'blob';\n    var TYPE_INT8ARRAY = 'si08';\n    var TYPE_UINT8ARRAY = 'ui08';\n    var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n    var TYPE_INT16ARRAY = 'si16';\n    var TYPE_INT32ARRAY = 'si32';\n    var TYPE_UINT16ARRAY = 'ur16';\n    var TYPE_UINT32ARRAY = 'ui32';\n    var TYPE_FLOAT32ARRAY = 'fl32';\n    var TYPE_FLOAT64ARRAY = 'fl64';\n    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\n    // Remove all keys from the datastore, effectively destroying all data in\n    // the app's key/value store!\n    function clear(callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                localStorage.clear();\n\n                if (callback) {\n                    callback();\n                }\n\n                resolve();\n            });\n        });\n    }\n\n    // Retrieve an item from the store. Unlike the original async_storage\n    // library in Gaia, we don't modify return values at all. If a key's value\n    // is `undefined`, we pass that value to the callback function.\n    function getItem(key, callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                try {\n                    var result = localStorage.getItem(keyPrefix + key);\n\n                    // If a result was found, parse it from the serialized\n                    // string into a JS object. If result isn't truthy, the key\n                    // is likely undefined and we'll pass it straight to the\n                    // callback.\n                    if (result) {\n                        result = _deserialize(result);\n                    }\n\n                    if (callback) {\n                        callback(result);\n                    }\n\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n\n    // Same as localStorage's key() method, except takes a callback.\n    function key(n, callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                var result = localStorage.key(n);\n\n                // Remove the prefix from the key, if a key is found.\n                if (result) {\n                    result = result.substring(keyPrefix.length);\n                }\n\n                if (callback) {\n                    callback(result);\n                }\n                resolve(result);\n            });\n        });\n    }\n\n    // Supply the number of keys in the datastore to the callback function.\n    function length(callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                var result = localStorage.length;\n\n                if (callback) {\n                    callback(result);\n                }\n\n                resolve(result);\n            });\n        });\n    }\n\n    // Remove an item from the store, nice and simple.\n    function removeItem(key, callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                localStorage.removeItem(keyPrefix + key);\n\n                if (callback) {\n                    callback();\n                }\n\n                resolve();\n            });\n        });\n    }\n\n    // Deserialize data we've inserted into a value column/field. We place\n    // special markers into our strings to mark them as encoded; this isn't\n    // as nice as a meta field, but it's the only sane thing we can do whilst\n    // keeping localStorage support intact.\n    //\n    // Oftentimes this will just deserialize JSON content, but if we have a\n    // special marker (SERIALIZED_MARKER, defined above), we will extract\n    // some kind of arraybuffer/binary data/typed array out of the string.\n    function _deserialize(value) {\n        // If we haven't marked this string as being specially serialized (i.e.\n        // something other than serialized JSON), we can just return it and be\n        // done with it.\n        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n            return JSON.parse(value);\n        }\n\n        // The following code deals with deserializing some kind of Blob or\n        // TypedArray. First we separate out the type of data we're dealing\n        // with from the data itself.\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n        // Fill the string into a ArrayBuffer.\n        var buffer = new ArrayBuffer(serializedString.length * 2); // 2 bytes for each char\n        var bufferView = new Uint16Array(buffer);\n        for (var i = serializedString.length - 1; i >= 0; i--) {\n            bufferView[i] = serializedString.charCodeAt(i);\n        }\n\n        // Return the right type based on the code/type set during\n        // serialization.\n        switch (type) {\n            case TYPE_ARRAYBUFFER:\n                return buffer;\n            case TYPE_BLOB:\n                return new Blob([buffer]);\n            case TYPE_INT8ARRAY:\n                return new Int8Array(buffer);\n            case TYPE_UINT8ARRAY:\n                return new Uint8Array(buffer);\n            case TYPE_UINT8CLAMPEDARRAY:\n                return new Uint8ClampedArray(buffer);\n            case TYPE_INT16ARRAY:\n                return new Int16Array(buffer);\n            case TYPE_UINT16ARRAY:\n                return new Uint16Array(buffer);\n            case TYPE_INT32ARRAY:\n                return new Int32Array(buffer);\n            case TYPE_UINT32ARRAY:\n                return new Uint32Array(buffer);\n            case TYPE_FLOAT32ARRAY:\n                return new Float32Array(buffer);\n            case TYPE_FLOAT64ARRAY:\n                return new Float64Array(buffer);\n            default:\n                throw new Error('Unkown type: ' + type);\n        }\n    }\n\n    // Converts a buffer to a string to store, serialized, in the backend\n    // storage library.\n    function _bufferToString(buffer) {\n        var str = '';\n        var uint16Array = new Uint16Array(buffer);\n\n        try {\n            str = String.fromCharCode.apply(null, uint16Array);\n        } catch (e) {\n            // This is a fallback implementation in case the first one does\n            // not work. This is required to get the phantomjs passing...\n            for (var i = 0; i < uint16Array.length; i++) {\n                str += String.fromCharCode(uint16Array[i]);\n            }\n        }\n\n        return str;\n    }\n\n    // Serialize a value, afterwards executing a callback (which usually\n    // instructs the `setItem()` callback/promise to be executed). This is how\n    // we store binary data with localStorage.\n    function _serialize(value, callback) {\n        var valueString = '';\n        if (value) {\n            valueString = value.toString();\n        }\n\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\n        // checks fail when running the tests using casper.js...\n        //\n        // TODO: See why those tests fail and use a better solution.\n        if (value && (value.toString() === '[object ArrayBuffer]' ||\n                      value.buffer && value.buffer.toString() === '[object ArrayBuffer]')) {\n            // Convert binary arrays to a string and prefix the string with\n            // a special marker.\n            var buffer;\n            var marker = SERIALIZED_MARKER;\n\n            if (value instanceof ArrayBuffer) {\n                buffer = value;\n                marker += TYPE_ARRAYBUFFER;\n            } else {\n                buffer = value.buffer;\n\n                if (valueString === '[object Int8Array]') {\n                    marker += TYPE_INT8ARRAY;\n                } else if (valueString === '[object Uint8Array]') {\n                    marker += TYPE_UINT8ARRAY;\n                } else if (valueString === '[object Uint8ClampedArray]') {\n                    marker += TYPE_UINT8CLAMPEDARRAY;\n                } else if (valueString === '[object Int16Array]') {\n                    marker += TYPE_INT16ARRAY;\n                } else if (valueString === '[object Uint16Array]') {\n                    marker += TYPE_UINT16ARRAY;\n                } else if (valueString === '[object Int32Array]') {\n                    marker += TYPE_INT32ARRAY;\n                } else if (valueString === '[object Uint32Array]') {\n                    marker += TYPE_UINT32ARRAY;\n                } else if (valueString === '[object Float32Array]') {\n                    marker += TYPE_FLOAT32ARRAY;\n                } else if (valueString === '[object Float64Array]') {\n                    marker += TYPE_FLOAT64ARRAY;\n                } else {\n                    callback(new Error(\"Failed to get type for BinaryArray\"));\n                }\n            }\n\n            var str = _bufferToString(buffer);\n\n            callback(null, marker + str);\n        } else if (valueString === \"[object Blob]\") {\n            // Conver the blob to a binaryArray and then to a string.\n            var fileReader = new FileReader();\n\n            fileReader.onload = function() {\n                var str = _bufferToString(this.result);\n\n                callback(null, SERIALIZED_MARKER + TYPE_BLOB + str);\n            };\n\n            fileReader.readAsArrayBuffer(value);\n        } else {\n            try {\n                callback(null, JSON.stringify(value));\n            } catch (e) {\n                if (window.console && window.console.error) {\n                    window.console.error(\"Couldn't convert value into a JSON string: \", value);\n                }\n                callback(e);\n            }\n        }\n    }\n\n    // Set a key's value and run an optional callback once the value is set.\n    // Unlike Gaia's implementation, the callback function is passed the value,\n    // in case you want to operate on that value only after you're sure it\n    // saved, or something like that.\n    function setItem(key, value, callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                // Convert undefined values to null.\n                // https://github.com/mozilla/localForage/pull/42\n                if (value === undefined) {\n                    value = null;\n                }\n\n                // Save the original value to pass to the callback.\n                var originalValue = value;\n\n                _serialize(value, function setSerialized(error, value) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        localStorage.setItem(keyPrefix + key, value);\n\n                        if (callback) {\n                            callback(originalValue);\n                        }\n\n                        resolve(originalValue);\n                    }\n                });\n            });\n        });\n    }\n\n    var localStorageWrapper = {\n        _driver: 'localStorageWrapper',\n        _initStorage: _initStorage,\n        // Default API, from Gaia/localStorage.\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('localStorageWrapper', function() {\n            return localStorageWrapper;\n        });\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = localStorageWrapper;\n    } else {\n        this.localStorageWrapper = localStorageWrapper;\n    }\n}).call(this);\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function() {\n    'use strict';\n\n    // Sadly, the best way to save binary data in WebSQL is Base64 serializing\n    // it, so this is how we store it to prevent very strange errors with less\n    // verbose ways of binary <-> string data storage.\n    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    var Promise = this.Promise;\n    var openDatabase = this.openDatabase;\n    var db = null;\n    var dbInfo = {\n        description: '',\n        name: 'localforage',\n        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size we can use\n        // without a prompt.\n        size: 4980736,\n        storeName: 'keyvaluepairs',\n        version: '1.0'\n    };\n\n    var SERIALIZED_MARKER = '__lfsc__:';\n    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n    // OMG the serializations!\n    var TYPE_ARRAYBUFFER = 'arbf';\n    var TYPE_BLOB = 'blob';\n    var TYPE_INT8ARRAY = 'si08';\n    var TYPE_UINT8ARRAY = 'ui08';\n    var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n    var TYPE_INT16ARRAY = 'si16';\n    var TYPE_INT32ARRAY = 'si32';\n    var TYPE_UINT16ARRAY = 'ur16';\n    var TYPE_UINT32ARRAY = 'ui32';\n    var TYPE_FLOAT32ARRAY = 'fl32';\n    var TYPE_FLOAT64ARRAY = 'fl64';\n    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\n    // If WebSQL methods aren't available, we can stop now.\n    if (!openDatabase) {\n        return;\n    }\n\n    // Open the WebSQL database (automatically creates one if one didn't\n    // previously exist), using any options set in window.localForageConfig.\n    function _initStorage(options) {\n        if (options) {\n            for (var i in dbInfo) {\n                if (options[i] !== undefined) {\n                    dbInfo[i] = typeof(options[i]) !== 'string' ? options[i].toString() : options[i];\n                }\n            }\n        }\n\n        return new Promise(function(resolve) {\n            // Open the database; the openDatabase API will automatically\n            // create it for us if it doesn't exist.\n            db = openDatabase(dbInfo.name, dbInfo.version, dbInfo.description,\n                              dbInfo.size);\n\n            // Create our key/value table if it doesn't exist.\n            db.transaction(function (t) {\n                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function() {\n                    resolve();\n                }, null);\n            });\n        });\n    }\n\n    function getItem(key, callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                db.transaction(function (t) {\n                    t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                        var result = results.rows.length ? results.rows.item(0).value : null;\n\n                        // Check to see if this is serialized content we need to\n                        // unpack.\n                        if (result) {\n                            result = _deserialize(result);\n                        }\n\n                        if (callback) {\n                            callback(result);\n                        }\n\n                        resolve(result);\n                    }, null);\n                });\n            });\n        });\n    }\n\n    function setItem(key, value, callback) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            _this.ready().then(function() {\n                // The localStorage API doesn't return undefined values in an\n                // \"expected\" way, so undefined is always cast to null in all\n                // drivers. See: https://github.com/mozilla/localForage/pull/42\n                if (value === undefined) {\n                    value = null;\n                }\n\n                // Save the original value to pass to the callback.\n                var originalValue = value;\n\n                _serialize(value, function setItemserializeValueCallback(error, value) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        db.transaction(function (t) {\n                            t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function() {\n                                if (callback) {\n                                    callback(originalValue);\n                                }\n\n                                resolve(originalValue);\n                            }, null);\n                        });\n                    }\n                });\n            });\n        });\n    }\n\n    function removeItem(key, callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                db.transaction(function (t) {\n                    t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function() {\n                        if (callback) {\n                            callback();\n                        }\n\n                        resolve();\n                    }, null);\n                });\n            });\n        });\n    }\n\n    // Deletes every item in the table.\n    // TODO: Find out if this resets the AUTO_INCREMENT number.\n    function clear(callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                db.transaction(function (t) {\n                    t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function() {\n                        if (callback) {\n                            callback();\n                        }\n\n                        resolve();\n                    }, null);\n                });\n            });\n        });\n    }\n\n    // Does a simple `COUNT(key)` to get the number of items stored in\n    // localForage.\n    function length(callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                db.transaction(function (t) {\n                    // Ahhh, SQL makes this one soooooo easy.\n                    t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                        var result = results.rows.item(0).c;\n\n                        if (callback) {\n                            callback(result);\n                        }\n\n                        resolve(result);\n                    }, null);\n                });\n            });\n        });\n    }\n\n    // Return the key located at key index X; essentially gets the key from a\n    // `WHERE id = ?`. This is the most efficient way I can think to implement\n    // this rarely-used (in my experience) part of the API, but it can seem\n    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n    // the ID of each key will change every time it's updated. Perhaps a stored\n    // procedure for the `setItem()` SQL would solve this problem?\n    // TODO: Don't change ID on `setItem()`.\n    function key(n, callback) {\n        var _this = this;\n        return new Promise(function(resolve) {\n            _this.ready().then(function() {\n                db.transaction(function (t) {\n                    t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                        var result = results.rows.length ? results.rows.item(0).key : null;\n\n                        if (callback) {\n                            callback(result);\n                        }\n\n                        resolve(result);\n                    }, null);\n                });\n            });\n        });\n    }\n\n    // Converts a buffer to a string to store, serialized, in the backend\n    // storage library.\n    function _bufferToString(buffer) {\n        // base64-arraybuffer\n        var bytes = new Uint8Array(buffer);\n        var i;\n        var base64String = '';\n\n        for (i = 0; i < bytes.length; i += 3) {\n            /*jslint bitwise: true */\n            base64String += BASE_CHARS[bytes[i] >> 2];\n            base64String += BASE_CHARS[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n            base64String += BASE_CHARS[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n            base64String += BASE_CHARS[bytes[i + 2] & 63];\n        }\n\n        if ((bytes.length % 3) === 2) {\n            base64String = base64String.substring(0, base64String.length - 1) + \"=\";\n        } else if (bytes.length % 3 === 1) {\n            base64String = base64String.substring(0, base64String.length - 2) + \"==\";\n        }\n\n        return base64String;\n    }\n\n    // Deserialize data we've inserted into a value column/field. We place\n    // special markers into our strings to mark them as encoded; this isn't\n    // as nice as a meta field, but it's the only sane thing we can do whilst\n    // keeping localStorage support intact.\n    //\n    // Oftentimes this will just deserialize JSON content, but if we have a\n    // special marker (SERIALIZED_MARKER, defined above), we will extract\n    // some kind of arraybuffer/binary data/typed array out of the string.\n    function _deserialize(value) {\n        // If we haven't marked this string as being specially serialized (i.e.\n        // something other than serialized JSON), we can just return it and be\n        // done with it.\n        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n            return JSON.parse(value);\n        }\n\n        // The following code deals with deserializing some kind of Blob or\n        // TypedArray. First we separate out the type of data we're dealing\n        // with from the data itself.\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n        // Fill the string into a ArrayBuffer.\n        var bufferLength = serializedString.length * 0.75;\n        var len = serializedString.length;\n        var i;\n        var p = 0;\n        var encoded1, encoded2, encoded3, encoded4;\n\n        if (serializedString[serializedString.length - 1] === \"=\") {\n            bufferLength--;\n            if (serializedString[serializedString.length - 2] === \"=\") {\n                bufferLength--;\n            }\n        }\n\n        var buffer = new ArrayBuffer(bufferLength);\n        var bytes = new Uint8Array(buffer);\n\n        for (i = 0; i < len; i+=4) {\n            encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n            encoded2 = BASE_CHARS.indexOf(serializedString[i+1]);\n            encoded3 = BASE_CHARS.indexOf(serializedString[i+2]);\n            encoded4 = BASE_CHARS.indexOf(serializedString[i+3]);\n\n            /*jslint bitwise: true */\n            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        }\n\n        // Return the right type based on the code/type set during\n        // serialization.\n        switch (type) {\n            case TYPE_ARRAYBUFFER:\n                return buffer;\n            case TYPE_BLOB:\n                return new Blob([buffer]);\n            case TYPE_INT8ARRAY:\n                return new Int8Array(buffer);\n            case TYPE_UINT8ARRAY:\n                return new Uint8Array(buffer);\n            case TYPE_UINT8CLAMPEDARRAY:\n                return new Uint8ClampedArray(buffer);\n            case TYPE_INT16ARRAY:\n                return new Int16Array(buffer);\n            case TYPE_UINT16ARRAY:\n                return new Uint16Array(buffer);\n            case TYPE_INT32ARRAY:\n                return new Int32Array(buffer);\n            case TYPE_UINT32ARRAY:\n                return new Uint32Array(buffer);\n            case TYPE_FLOAT32ARRAY:\n                return new Float32Array(buffer);\n            case TYPE_FLOAT64ARRAY:\n                return new Float64Array(buffer);\n            default:\n                throw new Error('Unkown type: ' + type);\n        }\n    }\n\n    // Serialize a value, afterwards executing a callback (which usually\n    // instructs the `setItem()` callback/promise to be executed). This is how\n    // we store binary data with localStorage.\n    function _serialize(value, callback) {\n        var valueString = '';\n        if (value) {\n            valueString = value.toString();\n        }\n\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\n        // checks fail when running the tests using casper.js...\n        //\n        // TODO: See why those tests fail and use a better solution.\n        if (value && (value.toString() === '[object ArrayBuffer]' ||\n                      value.buffer && value.buffer.toString() === '[object ArrayBuffer]')) {\n            // Convert binary arrays to a string and prefix the string with\n            // a special marker.\n            var buffer;\n            var marker = SERIALIZED_MARKER;\n\n            if (value instanceof ArrayBuffer) {\n                buffer = value;\n                marker += TYPE_ARRAYBUFFER;\n            } else {\n                buffer = value.buffer;\n\n                if (valueString === '[object Int8Array]') {\n                    marker += TYPE_INT8ARRAY;\n                } else if (valueString === '[object Uint8Array]') {\n                    marker += TYPE_UINT8ARRAY;\n                } else if (valueString === '[object Uint8ClampedArray]') {\n                    marker += TYPE_UINT8CLAMPEDARRAY;\n                } else if (valueString === '[object Int16Array]') {\n                    marker += TYPE_INT16ARRAY;\n                } else if (valueString === '[object Uint16Array]') {\n                    marker += TYPE_UINT16ARRAY;\n                } else if (valueString === '[object Int32Array]') {\n                    marker += TYPE_INT32ARRAY;\n                } else if (valueString === '[object Uint32Array]') {\n                    marker += TYPE_UINT32ARRAY;\n                } else if (valueString === '[object Float32Array]') {\n                    marker += TYPE_FLOAT32ARRAY;\n                } else if (valueString === '[object Float64Array]') {\n                    marker += TYPE_FLOAT64ARRAY;\n                } else {\n                    callback(new Error(\"Failed to get type for BinaryArray\"));\n                }\n            }\n\n            var str = _bufferToString(buffer);\n\n            callback(null, marker + str);\n        } else if (valueString === \"[object Blob]\") {\n            // Conver the blob to a binaryArray and then to a string.\n            var fileReader = new FileReader();\n\n            fileReader.onload = function() {\n                var str = _bufferToString(this.result);\n\n                callback(null, SERIALIZED_MARKER + TYPE_BLOB + str);\n            };\n\n            fileReader.readAsArrayBuffer(value);\n        } else {\n            try {\n                callback(null, JSON.stringify(value));\n            } catch (e) {\n                if (window.console && window.console.error) {\n                    window.console.error(\"Couldn't convert value into a JSON string: \", value);\n                }\n                callback(e);\n            }\n        }\n    }\n\n    var webSQLStorage = {\n        _driver: 'webSQLStorage',\n        _initStorage: _initStorage,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('webSQLStorage', function() {\n            return webSQLStorage;\n        });\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = webSQLStorage;\n    } else {\n        this.webSQLStorage = webSQLStorage;\n    }\n}).call(this);\n(function() {\n    'use strict';\n\n    // Promises!\n    var Promise = this.Promise;\n\n    // Avoid those magic constants!\n    var MODULE_TYPE_DEFINE = 1;\n    var MODULE_TYPE_EXPORT = 2;\n    var MODULE_TYPE_WINDOW = 3;\n\n    // Attaching to window (i.e. no module loader) is the assumed,\n    // simple default.\n    var moduleType = MODULE_TYPE_WINDOW;\n\n    // Find out what kind of module setup we have; if none, we'll just attach\n    // localForage to the main window.\n    if (typeof define === 'function' && define.amd) {\n        moduleType = MODULE_TYPE_DEFINE;\n    } else if (typeof module !== 'undefined' && module.exports) {\n        moduleType = MODULE_TYPE_EXPORT;\n    }\n\n    // Initialize IndexedDB; fall back to vendor-prefixed versions if needed.\n    var indexedDB = indexedDB || this.indexedDB || this.webkitIndexedDB ||\n                    this.mozIndexedDB || this.OIndexedDB ||\n                    this.msIndexedDB;\n\n    // Check for WebSQL.\n    var openDatabase = this.openDatabase;\n\n    // The actual localForage object that we expose as a module or via a global.\n    // It's extended by pulling in one of our other libraries.\n    var _this = this;\n    var localForage = {\n        INDEXEDDB: 'asyncStorage',\n        LOCALSTORAGE: 'localStorageWrapper',\n        WEBSQL: 'webSQLStorage',\n\n        config: {},\n\n        driver: function() {\n            return this._driver || null;\n        },\n\n        _ready: Promise.reject(new Error(\"setDriver() wasn't called\")),\n\n        setDriver: function(driverName, callback) {\n            var driverSet = new Promise(function(resolve, reject) {\n                if ((!indexedDB && driverName === localForage.INDEXEDDB) ||\n                    (!openDatabase && driverName === localForage.WEBSQL)) {\n                    reject(localForage);\n\n                    return;\n                }\n\n                localForage._ready = null;\n\n                // We allow localForage to be declared as a module or as a library\n                // available without AMD/require.js.\n                if (moduleType === MODULE_TYPE_DEFINE) {\n                    require([driverName], function(lib) {\n                        localForage._extend(lib);\n\n                        resolve(localForage);\n                    });\n\n                    // Return here so we don't resolve the promise twice.\n                    return;\n                } else if (moduleType === MODULE_TYPE_EXPORT) {\n                    // Making it browserify friendly\n                    var driver;\n                    switch (driverName) {\n                        case localForage.INDEXEDDB:\n                            driver = require('localforage/src/drivers/indexeddb');\n                            break;\n                        case localForage.LOCALSTORAGE:\n                            driver = require('localforage/src/drivers/localstorage');\n                            break;\n                        case localForage.WEBSQL:\n                            driver = require('localforage/src/drivers/websql');\n                    }\n\n                    localForage._extend(driver);\n                } else {\n                    localForage._extend(_this[driverName]);\n                }\n\n                resolve(localForage);\n            });\n\n            driverSet.then(callback, callback);\n\n            return driverSet;\n        },\n\n        ready: function(callback) {\n            if (this._ready === null) {\n                this._ready = this._initStorage(this.config);\n            }\n\n            this._ready.then(callback, callback);\n\n            return this._ready;\n        },\n\n        _extend: function(libraryMethodsAndProperties) {\n            for (var i in libraryMethodsAndProperties) {\n                if (libraryMethodsAndProperties.hasOwnProperty(i)) {\n                    this[i] = libraryMethodsAndProperties[i];\n                }\n            }\n        }\n    };\n\n    var storageLibrary;\n    // Check to see if IndexedDB is available; it's our preferred backend\n    // library.\n    if (indexedDB) {\n        storageLibrary = localForage.INDEXEDDB;\n    } else if (openDatabase) { // WebSQL is available, so we'll use that.\n        storageLibrary = localForage.WEBSQL;\n    } else { // If nothing else is available, we use localStorage.\n        storageLibrary = localForage.LOCALSTORAGE;\n    }\n\n    /* if window.localForageConfig is set */\n    if(this.localForageConfig) {\n        localForage.config = this.localForageConfig;\n    }\n\n    // Set the (default) driver.\n    localForage.setDriver(storageLibrary);\n\n    // We allow localForage to be declared as a module or as a library\n    // available without AMD/require.js.\n    if (moduleType === MODULE_TYPE_DEFINE) {\n        define(function() {\n            return localForage;\n        });\n    } else if (moduleType === MODULE_TYPE_EXPORT) {\n        module.exports = localForage;\n    } else {\n        this.localforage = localForage;\n    }\n}).call(this);\n"]}